<!DOCTYPE html>

<html>
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="../style.css" />
    <title>Tim's Site</title>
    <link rel="shortcut icon" href="#"/>
    <script type="text/javascript" src="../ContentLoader.js"></script>
  </head>
  
  <body onload="PopulatePageBar('..')">
    <h1 class="PageHeading PageText">Python Scripts In Unreal</h1>
    

      <ul id="PageBar">
      </ul>
      
      <div class="IframeContainer">
        <iframe src="https://www.youtube.com/embed/xqzLOTBfzaw" frameborder="0" allowfullscreen>
        </iframe>
      </div>
    
      <p class="ParagraphContent PageText">


This small project was originally inspired by another youtube <a href="https://www.youtube.com/watch?v=HELDYdr5i4Q&ab_channel=NicolasBrack">video</a>. 


I wanted try and recreate the realistic rendering that was being done with the legos in the youtube video so i set out to try and recreate it.

First I found the website the models were retrieved from mecabricks.com which made it easy to download different models and import them into Unreal Engine.

I originally thought the material on the lego bricks were being accomplished by baking in a procedural material in blender that was included on the mecabricks website into the separate bricks.

This was unrealistic since each lego brick was its own individual mesh with a local offset from the origin that coincided to its location on the lego set.

I tried joining all the bricks together as a single mesh in blender but there was  complications with each brick being a different color and then trying to bake it when its a single mesh so i didn't succeed with this approach.

When approaching the problem from inside Unreal Engine the problem became more complicated since each individual brick had its own material regardless as to whether they shared colors with other bricks and there could be thousands of bricks at a time depending on the lego set.

I knew i needed to have a master material for the imperfections and then instance which could adjust the material color based on a parameter but i also couldn't do this manually with thousands of static meshes.

After some more researching i remembered hearing about Unreal Engines python API that could be used to automate some processes>

I then utilized to api to create a colloection of all the materials of selected static meshes, create a material instance of a imperfection material, set the material instance base color or texture based on the materials in the collection and then set the newly created material to the associated static mesh.

This script would allow me to import any mesh i wanted from the website and then give it imperfections in seconds by just running a script.

Looking back on the script though it does seem i used the property matrix to change the multiple uses of different materials of the same color into a single material which would help speed up the process of the script. Although, this could easily be done with a separate python script and then these two scripts could be run one after another.


      </p>

      <pre>
      import unreal
      
      
      material_mesh_map = {}
      num_mappings = 0
      
      def contains_key(material_key):
          for key in material_mesh_map.keys():
              if key == material_key:
                  return True
          return False
      
      def create_imperfect_instance(mesh_material):
          master_instance = unreal.EditorAssetLibrary.load_asset('/Game/ImperfectShaders/MI_MasterImperfection.MI_MasterImperfection')
          asset_tools_object = unreal.AssetToolsHelpers.get_asset_tools()
          duplicate_instance = asset_tools_object.duplicate_asset("M_Imperfect_" + mesh_material.get_name(),'/Game/ImperfectShaders/Duplicate',master_instance)
          imperfect_instance = unreal.MaterialInstanceConstant.cast(duplicate_instance)
      
          uses_textures = len(unreal.MaterialEditingLibrary.get_used_textures(mesh_material)) != 0
      
          #only support one texture materials
          if uses_textures:
              material_texture = unreal.MaterialEditingLibrary.get_used_textures(mesh_material)[0]
              unreal.MaterialEditingLibrary.set_material_instance_scalar_parameter_value(imperfect_instance,"bUseTexture",1.0)
              unreal.MaterialEditingLibrary.set_material_instance_texture_parameter_value(imperfect_instance,"TextureParameter",material_texture)
          else:
              diffuse_color = unreal.MaterialEditingLibrary.get_material_default_vector_parameter_value(mesh_material,"Param")
              unreal.MaterialEditingLibrary.set_material_instance_vector_parameter_value(imperfect_instance,"DiffuseParameter",diffuse_color)
      
          return imperfect_instance
          
      
      selected_assets = unreal.EditorUtilityLibrary.get_selected_assets()
      
      for selected_asset in selected_assets:
          sm_asset_cast = unreal.StaticMesh.cast(selected_asset)
          if sm_asset_cast != None:
              if contains_key(sm_asset_cast.get_material(0)):
                  material_mesh_map[sm_asset_cast.get_material(0)].append(sm_asset_cast)
              else:
                  unreal.log("Creating new mapping: "+str(num_mappings))
                  num_mappings+=1
                  material_mesh_map.update({sm_asset_cast.get_material(0):[]})
                  material_mesh_map[sm_asset_cast.get_material(0)].append(sm_asset_cast)
      
      for current_material in material_mesh_map.keys():
          imperfect_material = create_imperfect_instance(current_material)
          for current_mesh in material_mesh_map[current_material]:
              current_mesh.set_material(0,imperfect_material)
              unreal.log("Material assigned to mesh: "+current_mesh.get_name())
      </pre>
                  
          

  </body>
</html>
